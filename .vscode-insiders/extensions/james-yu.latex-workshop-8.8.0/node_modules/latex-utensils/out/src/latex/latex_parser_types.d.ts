import { Location } from '../pegjs/pegjs_types';
export declare type TextString = {
    kind: 'text.string';
    content: string;
    location: Location;
};
export declare function isTextString(node: Node): node is TextString;
export declare type Command = {
    kind: 'command';
    name: string;
    args: (OptionalArg | Group)[];
    location: Location;
};
export declare function isCommand(node: Node): node is Command;
export declare type AmsMathTextCommand = {
    kind: 'command.text';
    arg: Group;
    location: Location;
};
export declare function isAmsMathTextCommand(node: Node): node is AmsMathTextCommand;
export declare type DefCommand = {
    kind: 'command.def';
    name: 'def';
    token: string;
    args: (OptionalArg | CommandParameter | Group)[];
};
export declare function isDefCommand(node: Node): node is DefCommand;
export declare type Environment = {
    kind: 'env';
    name: string;
    args: (OptionalArg | Group)[];
    content: Node[];
    location: Location;
};
export declare function isEnvironment(node: Node): node is Environment;
export declare type MathEnv = {
    kind: 'env.math.align';
    name: string;
    args: (OptionalArg | Group)[];
    content: Node[];
    location: Location;
};
export declare function isMathEnv(node: Node): node is MathEnv;
export declare type MathEnvAligned = {
    kind: 'env.math.aligned';
    name: string;
    args: (OptionalArg | Group)[];
    content: Node[];
    location: Location;
};
export declare function isMathEnvAligned(node: Node): node is MathEnvAligned;
export declare type Group = {
    kind: 'arg.group';
    content: Node[];
    location: Location;
};
export declare function isGroup(node: Node): node is Group;
export declare type OptionalArg = {
    kind: 'arg.optional';
    content: Node[];
    location: Location;
};
export declare function isOptionalArg(node: Node): node is OptionalArg;
export declare type Parbreak = {
    kind: 'parbreak';
    location: Location;
};
export declare function isParbreak(node: Node): node is Parbreak;
export declare type Superscript = {
    kind: 'superscript';
    content: Node[];
    location: Location;
};
export declare function isSuperscript(node: Node): node is Superscript;
export declare type Subscript = {
    kind: 'subscript';
    content: Node[];
    location: Location;
};
export declare function isSubscript(node: Node): node is Subscript;
export declare type AlignmentTab = {
    kind: 'alignmentTab';
    location: Location;
};
export declare function isAlignmentTab(node: Node): node is AlignmentTab;
export declare type CommandParameter = {
    kind: 'commandParameter';
    nargs: string;
    location: Location;
};
export declare function isCommandParameter(node: Node): node is CommandParameter;
export declare type ActiveCharacter = {
    kind: 'activeCharacter';
    location: Location;
};
export declare function isActiveCharacter(node: Node): node is ActiveCharacter;
export declare type Ignore = {
    kind: 'ignore';
    location: Location;
};
export declare function isIgnore(node: Node): node is Ignore;
export declare type Verb = {
    kind: 'verb';
    name: string;
    escape: string;
    content: string;
    location: Location;
};
export declare function isVerb(node: Node): node is Verb;
export declare type Verbatim = {
    kind: 'env.verbatim';
    name: string;
    content: string;
    location: Location;
};
export declare function isVerbatim(node: Node): node is Verbatim;
export declare type Minted = {
    kind: 'env.minted';
    name: 'minted';
    args: (OptionalArg | Group)[];
    content: string;
    location: Location;
};
export declare function isMinted(node: Node): node is Minted;
export declare type Lstlisting = {
    kind: 'env.lstlisting';
    name: 'lstlisting';
    arg?: OptionalArg;
    content: string;
    location: Location;
};
export declare function isLstlisting(node: Node): node is Lstlisting;
export declare type InlienMath = {
    kind: 'inlineMath';
    content: Node[];
    location: Location;
};
export declare function isInlienMath(node: Node): node is InlienMath;
export declare type DisplayMath = {
    kind: 'displayMath';
    content: Node[];
    location: Location;
};
export declare function isDisplayMath(node: Node): node is DisplayMath;
export declare type MathCharacter = {
    kind: 'math.character';
    content: string;
};
export declare function isMathCharacter(node: Node): node is MathCharacter;
export declare type MathMatchingParen = {
    kind: 'math.matching_paren';
    left: string;
    right: string;
    content: Node[];
    location: Location;
};
export declare function isMathMatchingParen(node: Node): node is MathMatchingParen;
export declare function hasContent(node: Node): node is Extract<Node, {
    content: any;
}>;
export declare function hasContentArray(node: Node): node is Extract<Node, {
    content: Node[];
}>;
export declare function hasArgsArray(node: Node): node is Extract<Node, {
    args: Node[];
}>;
export declare type Node = TextString | Command | AmsMathTextCommand | DefCommand | Environment | Group | OptionalArg | InlienMath | DisplayMath | MathCharacter | MathMatchingParen | MathEnv | MathEnvAligned | Parbreak | Superscript | Subscript | AlignmentTab | CommandParameter | ActiveCharacter | Ignore | Verb | Verbatim | Minted | Lstlisting;
export declare type Comment = {
    kind: 'comment';
    content: string;
    location: Location;
};
export declare type AstRoot = {
    kind: 'ast.root';
    content: Node[];
    comment?: Comment[];
};
export declare function isAstRoot(ast: LatexAst): ast is AstRoot;
export declare type AstPreamble = {
    kind: 'ast.preamble';
    content: Node[];
    comment?: Comment[];
    rest: string;
};
export declare function isAstPreamble(ast: LatexAst): ast is AstPreamble;
export declare type LatexAst = AstRoot | AstPreamble;
